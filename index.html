<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Touch Grass Simulator ðŸŒ±</title>
<style>
  :root { --bg:#0b1220; --panel:#18243e; --text:#e9f0ff; --btn:#213152; }
  *{box-sizing:border-box}
  body{
    margin:0;font-family:system-ui,Segoe UI,Arial,sans-serif;
    background:var(--bg);color:var(--text);
    min-height:100vh;display:flex;flex-direction:column;align-items:center;
    gap:8px;padding:10px
  }
  h1{margin:.5rem 0 0}
  .hud{display:flex;gap:12px;align-items:center}
  .hud button{background:var(--btn);color:var(--text);border:none;padding:6px 10px;border-radius:8px;cursor:pointer}
  .board{
    width:min(92vw,520px);height:min(92vw,520px,520px);
    background:var(--panel);position:relative;border-radius:14px;overflow:hidden;
    box-shadow:0 6px 24px rgba(0,0,0,.35)
  }
  .player{position:absolute;left:20px;top:20px;width:48px;height:48px}
  .tile,.bubble{position:absolute;display:flex;flex-direction:column;align-items:center;text-align:center;pointer-events:none}
  .tile img,.bubble img{width:50px;height:50px}
  .tile span,.bubble span{font-size:11px;color:#fff;margin-top:2px}
  .grass{position:absolute;right:0;bottom:0;width:100px;height:100px}
  .toast{
    position:absolute;top:10px;left:50%;transform:translateX(-50%);
    background:#111a2b;padding:8px 14px;border-radius:8px;opacity:0;transition:opacity .25s
  }
  .toast.show{opacity:1}
  .overlay{
    position:absolute;inset:0;background:rgba(0,0,0,.7);
    display:none;align-items:center;justify-content:center;flex-direction:column;gap:8px;
    text-align:center;z-index:10;padding:10px
  }
  .overlay button{background:var(--btn);color:#fff;border:none;padding:8px 14px;border-radius:8px;cursor:pointer}
  .stunned{filter:saturate(.6) brightness(.9)}
</style>
</head>
<body>
  <h1>Touch Grass Simulator ðŸŒ±</h1>
  <div class="hud">
    <span>Score: <b id="score">0</b></span> |
    <span>Time: <b id="timer">30</b>s</span> |
    <span>Level: <b id="level">1</b></span>
    <button id="mute">ðŸ”Š Mute</button>
  </div>

  <div class="board" id="board">
    <div class="grass" id="grass"></div>
    <div class="player" id="player"></div>
    <div class="toast" id="toast"></div>
    <div class="overlay" id="overlay">
      <h2 id="end-title">Level Complete!</h2>
      <p id="end-desc">You touched grass!</p>
      <div style="display:flex;gap:8px">
        <button id="restart">Start Over</button>
        <button id="next">Next Level</button>
      </div>
    </div>
  </div>

<script>
  /* -------- Sprites -------- */
const SPRITES={
  player:`data:image/svg+xml;utf8,${encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><rect x='6' y='6' width='52' height='52' rx='10' fill='#3498db' stroke='#000' stroke-width='3'/><circle cx='26' cy='26' r='4' fill='#000'/><circle cx='38' cy='26' r='4' fill='#000'/><path d='M22 42 q10 8 20 0' fill='none' stroke='#000' stroke-width='3' stroke-linecap='round'/></svg>`)}`,
  grass:`data:image/svg+xml;utf8,${encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><rect width='64' height='20' y='44' fill='#0ea14b'/><g stroke='#0ea14b' stroke-width='4' stroke-linecap='round' fill='none'><path d='M8 60 L12 44'/><path d='M16 60 L20 44'/><path d='M24 60 L28 44'/><path d='M36 60 L40 44'/><path d='M44 60 L48 44'/><path d='M52 60 L56 44'/></g></svg>`)}`,
  doom:`data:image/svg+xml;utf8,${encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><rect x='16' y='6' width='32' height='52' rx='6' fill='#111' stroke='#bbb' stroke-width='3'/><rect x='21' y='14' width='22' height='30' rx='3' fill='#1e1e1e'/><path d='M23 18 h18 M23 24 h18 M23 30 h18 M23 36 h14' stroke='#61dafb' stroke-width='3'/></svg>`)}`,
  brain:`data:image/svg+xml;utf8,${encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><path d='M20 18 a12 12 0 0 1 24 0 v0 a12 12 0 0 1 8 12 v4 a14 14 0 0 1 -14 14 h-12 a14 14 0 0 1 -14 -14 v-4 a12 12 0 0 1 8 -12z' fill='#ff6fab' stroke='#b21e6b' stroke-width='3'/><path d='M26 18 v28 M38 18 v28' stroke='#b21e6b' stroke-width='3'/></svg>`)}`,
  couch:`data:image/svg+xml;utf8,${encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><rect x='8' y='28' width='48' height='16' rx='4' fill='#c66' stroke='#722' stroke-width='3'/><rect x='12' y='22' width='40' height='10' rx='4' fill='#e88' stroke='#722' stroke-width='3'/><rect x='10' y='44' width='44' height='6' rx='2' fill='#833'/></svg>`)}`,
  vibe:`data:image/svg+xml;utf8,${encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><polygon points='32,6 38,24 58,24 42,36 48,54 32,43 16,54 22,36 6,24 26,24' fill='#ffd54a' stroke='#a47d00' stroke-width='3'/><text x='32' y='59' font-size='14' fill='#fff' text-anchor='middle' font-family='system-ui'>+1</text></svg>`)}`,
  sprout:`data:image/svg+xml;utf8,${encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><rect x='28' y='28' width='8' height='28' fill='#207d3a'/><ellipse cx='22' cy='24' rx='12' ry='8' fill='#2ecc71'/><ellipse cx='42' cy='18' rx='10' ry='7' fill='#2ecc71'/></svg>`)}`,
  sun:`data:image/svg+xml;utf8,${encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><circle cx='32' cy='32' r='12' fill='#ffd34a' stroke='#a47d00' stroke-width='3'/><g stroke='#ffd34a' stroke-width='4'><line x1='32' y1='6' x2='32' y2='16'/><line x1='32' y1='48' x2='32' y2='58'/><line x1='6' y1='32' x2='16' y2='32'/><line x1='48' y1='32' x2='58' y2='32'/><line x1='12' y1='12' x2='19' y2='19'/><line x1='52' y1='12' x2='45' y2='19'/><line x1='12' y1='52' x2='19' y2='45'/><line x1='52' y1='52' x2='45' y2='45'/></g></svg>`)}`
};

/* DOM refs */
const board=document.getElementById('board');
const player=document.getElementById('player');
const grass=document.getElementById('grass');
const toast=document.getElementById('toast');
const overlay=document.getElementById('overlay');
const endTitle=document.getElementById('end-title');
const endDesc=document.getElementById('end-desc');
const restartBtn=document.getElementById('restart');
const nextBtn=document.getElementById('next');
const muteBtn=document.getElementById('mute');
const scoreEl=document.getElementById('score');
const timerEl=document.getElementById('timer');
const levelEl=document.getElementById('level');

/* State */
let dragging=false,offsetX=0,offsetY=0;
let score=0,time=30,level=1,running=true,muted=false;
let bubbles=[],tiles=[];
let pendingX=20,pendingY=20,lastX=20,lastY=20;
let stunnedUntil=0;
let invincibleUntil=0;   // brief grace so tiles can't instantly re-pin you

// timing
const BASE_TIME = 30;        // per-level timer reset base
const MAX_STEP  = 12;        // swept movement micro-steps (lower = stricter)

/* Place sprites */
grass.innerHTML=`<img alt="grass" src="${SPRITES.grass}" style="width:100%;height:100%">`;
player.innerHTML=`<img alt="player" src="${SPRITES.player}" style="width:100%;height:100%">`;

/* Pools */
const badHabits=[{img:SPRITES.doom,label:"Doomscrolling"},{img:SPRITES.brain,label:"Brain Rot"},{img:SPRITES.couch,label:"Procrastinate"}];
const goodVibes=[{img:SPRITES.vibe,label:"Vibe+1"},{img:SPRITES.sprout,label:"Grass Power"},{img:SPRITES.sun,label:"Vitamin D"}];
const rageTile=["ðŸ”¥ Back to spawn, bot.","ðŸ’€ NPC detected.","ðŸ“‰ Skill issueâ€¦"];
const rageTime=["âŒ› Ran out of time, doomscroller.","ðŸ˜­ Couldn't even touch grass."];
const winMsgs=["ðŸŒ± Fresh air unlocked!","âœ¨ Your sanity +10."];

/* Audio */
let audioCtx=null;
function ensureAudio(){ if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)(); }
function beep(freq=440,dur=0.1){ if(muted) return; ensureAudio(); const t0=audioCtx.currentTime; const o=audioCtx.createOscillator(),g=audioCtx.createGain(); o.type='square'; o.frequency.value=freq; g.gain.value=0.05; g.gain.exponentialRampToValueAtTime(0.0001,t0+dur); o.connect(g).connect(audioCtx.destination); o.start(t0); o.stop(t0+dur); }

/* Helpers */
function showToast(m){ toast.textContent=m; toast.classList.add('show'); setTimeout(()=>toast.classList.remove('show'),900); }
function rectsOverlap(a,b){ return !(b.right<a.left||b.left>a.right||b.bottom<a.top||b.top>a.bottom); }

/* --- segment-vs-rect helpers for anti-ghosting --- */
function segIntersectsRect(x1,y1,x2,y2, r){
  if(pointInRect(x1,y1,r) || pointInRect(x2,y2,r)) return true;
  const edges = [
    [r.left, r.top,    r.right, r.top   ],
    [r.right,r.top,    r.right, r.bottom],
    [r.right,r.bottom, r.left,  r.bottom],
    [r.left, r.bottom, r.left,  r.top   ]
  ];
  for(const [ax,ay,bx,by] of edges){
    if(segmentsIntersect(x1,y1,x2,y2, ax,ay,bx,by)) return true;
  }
  return false;
}
function pointInRect(x,y,r){ return x>=r.left && x<=r.right && y>=r.top && y<=r.bottom; }
function segmentsIntersect(x1,y1,x2,y2, x3,y3,x4,y4){
  function ccw(ax,ay,bx,by,cx,cy){ return (cy-ay)*(bx-ax) > (by-ay)*(cx-ax); }
  return (ccw(x1,y1,x3,y3,x4,y4) !== ccw(x2,y2,x3,y3,x4,y4)) &&
         (ccw(x1,y1,x2,y2,x3,y3) !== ccw(x1,y1,x2,y2,x4,y4));
}

/* Safe respawn + short invincibility */
function resetPlayer(){
  pendingX=20; pendingY=20; lastX=20; lastY=20;

  // nudge spawn if overlapping a tile
  let tries=0;
  while(
    tiles.some(t => rectsOverlap(
      {left:pendingX, top:pendingY, right:pendingX+48, bottom:pendingY+48},
      t.getBoundingClientRect()
    )) && tries<20
  ){
    pendingX += 20; pendingY += 20; tries++;
  }

  player.style.left=pendingX+"px";
  player.style.top =pendingY+"px";

  const now=performance.now();
  stunnedUntil    = now + 250;   // subtle visual "stun"
  invincibleUntil = now + 900;   // can't be re-pinned immediately

  player.classList.add('stunned');
  setTimeout(()=>player.classList.remove('stunned'),300);
}

/* Spawners */
function spawnTile(speedBase){ 
  const d=badHabits[Math.random()*badHabits.length|0];
  const el=document.createElement('div'); el.className='tile';
  let x,y; 
  do{ x=60+Math.random()*350; y=20+Math.random()*350; } // keep away from spawn corner
  while(Math.hypot(x-20,y-20)<120);
  el.style.left=x+'px'; el.style.top=y+'px';
  el.innerHTML=`<img src="${d.img}" alt=""><span>${d.label}</span>`;
  board.appendChild(el);
  const ang=Math.random()*Math.PI*2, sp=speedBase*(0.85+Math.random()*0.3);
  el.vx=Math.cos(ang)*sp; el.vy=Math.sin(ang)*sp;
  tiles.push(el);
}
function spawnBubble(){ 
  const d=goodVibes[Math.random()*goodVibes.length|0];
  const b=document.createElement('div'); b.className='bubble';
  b.style.left=(Math.random()*400)+'px'; 
  b.style.top =(Math.random()*400)+'px';
  b.innerHTML=`<img src="${d.img}" alt=""><span>${d.label}</span>`;
  board.appendChild(b); 
  bubbles.push({el:b}); 
  setTimeout(()=>{b.remove();bubbles=bubbles.filter(x=>x.el!==b)},4500); 
}
  /* Timer */
let tickId=setInterval(()=>{},1000);
function startTimer(){ clearInterval(tickId); tickId=setInterval(tick,1000); }
function tick(){ if(!running) return; time--; timerEl.textContent=time; if(time<=0) gameOver(false); }

/* Collisions: instant win on grass, +5s bubbles, invincibility for tiles */
function checkCollisions(){ 
  if(!running) return; 
  const pr=player.getBoundingClientRect(), gr=grass.getBoundingClientRect(); 
  const px=pr.left+pr.width/2, py=pr.top+pr.height/2; 

  // --- instant win on grass ---
  if(px>gr.left&&px<gr.right&&py>gr.top&&py<gr.bottom){
    gameOver(true);
    return;
  }

  // tile hits only if not invincible
  const now = performance.now();
  if(now > invincibleUntil){
    for(const t of tiles){
      if(rectsOverlap(pr,t.getBoundingClientRect())){
        resetPlayer();
        showToast(rageTile[Math.random()*rageTile.length|0]);
        beep(300,0.12);
        break;
      }
    }
  }

  // good bubbles -> +1 score, +5s time
  for(const b of bubbles){
    if(rectsOverlap(pr,b.el.getBoundingClientRect())){
      score++; scoreEl.textContent=score;
      time = Math.min(999, time + 5);
      timerEl.textContent = time;
      showToast("âœ¨ "+b.el.innerText+"  (+5s)");
      beep(620,0.1);
    }
  }
}

/* Movement: anti-ghost (path collision) + hard anti-pin for tiles */
function updatePlayer(){ 
  const now=performance.now(); 
  if(now<stunnedUntil){ requestAnimationFrame(updatePlayer); return; }

  if(running){ 
    const rect=board.getBoundingClientRect();
    const pr = player.getBoundingClientRect();
    const pcx = pr.left + pr.width/2 - rect.left;
    const pcy = pr.top  + pr.height/2 - rect.top;

    tiles.forEach(t=>{
      let x=t.offsetLeft+t.vx, y=t.offsetTop+t.vy;

      // walls bounce
      if(x<=0||x+60>=rect.width)  t.vx*=-1;
      if(y<=0||y+60>=rect.height) t.vy*=-1;

      // predicted tile rect
      let nx=x, ny=y;
      const tx=nx+30, ty=ny+30;
      const dx=tx-pcx, dy=ty-pcy;
      let d=Math.hypot(dx,dy);

      // repel near player
      const AVOID_R=95;
      if(d>0 && d<AVOID_R){
        const s=(AVOID_R-d)/AVOID_R;
        t.vx += (dx/d)*0.7*s;
        t.vy += (dy/d)*0.7*s;
      }

      // resolve overlap (separate tile out of player)
      const tileRect={left:nx, top:ny, right:nx+60, bottom:ny+60};
      const overlap = !(tileRect.right<pr.left||tileRect.left>pr.right||tileRect.bottom<pr.top||tileRect.top>pr.bottom);
      if(overlap){
        const oLeft   = pr.right  - tileRect.left;
        const oRight  = tileRect.right - pr.left;
        const oTop    = pr.bottom - tileRect.top;
        const oBottom = tileRect.bottom - pr.top;
        const xPush = (oLeft < oRight) ? -oLeft :  oRight;
        const yPush = (oTop  < oBottom)? -oTop  :  oBottom;

        if(Math.abs(xPush) < Math.abs(yPush)){
          nx += xPush;
          t.vx = -Math.sign(xPush) * Math.max(Math.abs(t.vx), 1.2);
        }else{
          ny += yPush;
          t.vy = -Math.sign(yPush) * Math.max(Math.abs(t.vy), 1.2);
        }
        invincibleUntil = Math.max(invincibleUntil, performance.now()+250);
      }

      // minimum drift; cap max speed
      const MIN_SPEED=0.7, MAX_SPEED=4 + level*0.45;
      let sp=Math.hypot(t.vx,t.vy);
      if(sp<MIN_SPEED){
        const ang=Math.random()*Math.PI*2;
        t.vx+=Math.cos(ang)*MIN_SPEED;
        t.vy+=Math.sin(ang)*MIN_SPEED;
      }else if(sp>MAX_SPEED){
        t.vx=t.vx/sp*MAX_SPEED; t.vy=t.vy/sp*MAX_SPEED;
      }

      // commit
      nx=Math.max(0,Math.min(rect.width -60,nx));
      ny=Math.max(0,Math.min(rect.height-60,ny));
      t.style.left=nx+'px'; t.style.top=ny+'px';
    });
  }

  /* --- Player swept movement with path collision to prevent ghosting --- */
  let dx=pendingX-lastX, dy=pendingY-lastY, dist=Math.hypot(dx,dy);
  let steps=Math.max(1,Math.ceil(dist/MAX_STEP));

  for(let i=0;i<steps;i++){
    const nx = lastX + dx/steps;
    const ny = lastY + dy/steps;

    // segment path from current center to next center vs each tile rect (board coords)
    const now = performance.now();
    if(now > invincibleUntil){
      const prNow = {left:lastX, top:lastY, right:lastX+48, bottom:lastY+48};
      const cx1 = prNow.left+24, cy1 = prNow.top+24;
      const cx2 = nx+24,         cy2 = ny+24;

      let hit = false;
      const br = board.getBoundingClientRect();
      for(const t of tiles){
        const tr = t.getBoundingClientRect();
        const r = { left: tr.left - br.left, top: tr.top - br.top,
                    right: tr.right - br.left, bottom: tr.bottom - br.top };
        if(segIntersectsRect(cx1,cy1,cx2,cy2, r)){ hit = true; break; }
      }
      if(hit){
        resetPlayer();
        showToast(rageTile[Math.random()*rageTile.length|0]);
        beep(300,0.12);
        break;
      }
    }

    // move and check normal overlaps (win, bubbles, etc.)
    lastX = nx; lastY = ny;
    player.style.left=lastX+'px'; player.style.top=lastY+'px';
    checkCollisions();
    if(performance.now()<stunnedUntil) break;
  }
  requestAnimationFrame(updatePlayer);
}
requestAnimationFrame(updatePlayer);

/* Controls */
board.addEventListener('mousedown',e=>{dragging=true;offsetX=e.offsetX;offsetY=e.offsetY;});
document.addEventListener('mouseup',()=>dragging=false);
document.addEventListener('mousemove',e=>{
  if(!dragging||!running) return;
  const r=board.getBoundingClientRect();
  pendingX=Math.max(0,Math.min(r.width -40, e.clientX-r.left-offsetX));
  pendingY=Math.max(0,Math.min(r.height-40, e.clientY-r.top -offsetY));
});
player.addEventListener('touchstart',e=>{
  e.preventDefault(); dragging=true;
  const t=e.touches[0], r=player.getBoundingClientRect();
  offsetX=t.clientX-r.left; offsetY=t.clientY-r.top;
},{passive:false});
document.addEventListener('touchend',()=>dragging=false);
document.addEventListener('touchmove',e=>{
  if(!dragging||!running) return;
  e.preventDefault();
  const t=e.touches[0], r=board.getBoundingClientRect();
  pendingX=Math.max(0,Math.min(r.width -40, t.clientX-r.left-offsetX));
  pendingY=Math.max(0,Math.min(r.height-40, t.clientY-r.top -offsetY));
},{passive:false});

/* Game flow */
function startLevel(lv){ 
  level=lv; levelEl.textContent=level; 
  time=Math.max(10, BASE_TIME - (lv-1)*3);  // reset timer each level
  timerEl.textContent=time; 
  tiles.forEach(t=>t.remove()); tiles=[]; 
  bubbles.forEach(b=>b.el.remove()); bubbles=[]; 
  for(let i=0;i<lv+2;i++) spawnTile(1+lv*0.3); 
  resetPlayer(); 
  running=true; 
  overlay.style.display="none"; 
  startTimer(); 
}
function gameOver(win){ 
  running=false; overlay.style.display="flex"; 
  if(win){ 
    endTitle.textContent="You touched grass!"; 
    endDesc.textContent=winMsgs[Math.random()*winMsgs.length|0]; 
    score+=10; scoreEl.textContent=score; 
    nextBtn.style.display="inline-block"; 
  } else { 
    endTitle.textContent="Game Over"; 
    endDesc.textContent=rageTime[Math.random()*rageTime.length|0]; 
    nextBtn.style.display="none"; 
  } 
}

/* Buttons */
restartBtn.onclick=()=>{ overlay.style.display="none"; score=0; scoreEl.textContent=0; startLevel(1); };
nextBtn.onclick   =()=>{ overlay.style.display="none"; startLevel(level+1); };
muteBtn.onclick   =()=>{ muted=!muted; muteBtn.textContent=muted?"ðŸ”‡ Unmute":"ðŸ”Š Mute"; };

/* Bubble spawner */
setInterval(()=>{ if(running) spawnBubble(); },2500);

/* Init */
resetPlayer();
startLevel(1);
</script>
</body>
</html>
